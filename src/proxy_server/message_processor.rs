use crate::access_control_tree::{AccessControlTree, AllowRule, BlockRule, Rule, SocketAddress};
use crate::firewall_backend::FirewallBackend;
use crate::proxy_server::access_logger::{AccessLogger, LogEntryKind};
use anyhow::Context;
use hickory_proto::op::{OpCode, ResponseCode};
use hickory_proto::rr::{DNSClass, RData, RecordType};
use hickory_proto::serialize::binary::BinEncodable;
use rand::Rng;
use std::net::IpAddr;

pub struct DnsMessageProcessor {
    act: AccessControlTree,
    pub access_logger: AccessLogger,
    min_ttl: chrono::Duration,
    max_ttl: chrono::Duration,
    firewall_backend: Box<dyn FirewallBackend>,
}

pub enum RequestReaction {
    Discard,
    ForwardToUpstream { forwarded_request: ForwardedRequest },
    RespondToClient,
}

pub struct ForwardedRequest {
    pub original_request_header: hickory_proto::op::Header,

    /// The request ID of the forwarded request, which was generated by the proxy.
    /// Does NOT match the request ID in the `original_request_header`.
    request_id: u16,

    // Mapping of [domain name] -> [list of socket addr]. Used to create firewall rules.
    // Vec instead of HashMap because we expect a single domain name for most requests.
    // A map would waste memory.
    allowed_domains: Vec<AllowedDomain>,
}

#[derive(Clone)]
struct AllowedDomain {
    domain_name: hickory_proto::rr::Name,
    socket_addrs: Vec<SocketAddress>,
}

#[derive(Clone)]
struct BlockedDomain {
    domain_name: hickory_proto::rr::Name,
    rule: BlockRule,
}

pub enum ResponseReaction {
    /// Discard & receive another response from the server
    Discard,
    ForwardToClient,
}

impl DnsMessageProcessor {
    pub fn new(
        act: AccessControlTree,
        min_ttl: chrono::Duration,
        max_ttl: chrono::Duration,
        firewall_backend: Box<dyn FirewallBackend>,
    ) -> Self {
        Self {
            act,
            access_logger: AccessLogger {},
            min_ttl,
            max_ttl,
            firewall_backend,
        }
    }

    pub fn process_client_request(
        &self,
        client_address: IpAddr,
        buffer: &mut Vec<u8>,
    ) -> RequestReaction {
        // Parse request
        let request = match hickory_proto::op::Message::from_vec(buffer) {
            Ok(request) => request,
            Err(e) => {
                self.access_logger.log(
                    client_address,
                    LogEntryKind::RequestError,
                    None,
                    format!("Request decoding failed: {e:#}"),
                );
                return RequestReaction::Discard;
            }
        };

        let request_id = request.header().id();

        let act_matcher = self.act.matcher(client_address);

        // We still continue even if act_matcher is empty (sender not allowed), to generate log messages

        // Validate for QUERY OPCODE, unless all DNS queries are allowed
        if !act_matcher.allow_all_dns_queries() {
            if request.header().op_code() != OpCode::Query {
                self.access_logger.log(
                    client_address,
                    LogEntryKind::RequestWarning,
                    Some(request_id),
                    format!(
                        "Unexpected OPCODE {:?} (expected StandardQuery)",
                        request.header().op_code()
                    ),
                );
                Self::build_response(&request, ResponseCode::Refused, buffer);
                return RequestReaction::RespondToClient;
            }

            if request.query_count() == 0 {
                self.access_logger.log(
                    client_address,
                    LogEntryKind::RequestWarning,
                    Some(request_id),
                    "Empty request",
                );
                Self::build_response(&request, ResponseCode::Refused, buffer);
                return RequestReaction::RespondToClient;
            }
        }

        // Gather requested domain names
        let mut allowed_domains = Vec::with_capacity(request.query_count() as usize);
        let mut blocked_domains = Vec::with_capacity(request.query_count() as usize);

        for question in request.queries() {
            // Note that qnames always end with a dot!
            let qname = question.name();
            let rule = act_matcher.find_domain_rule(&qname.to_string());

            match rule {
                Rule::Block(BlockRule::RefuseDnsQuery) => {
                    self.access_logger.log(
                        client_address,
                        LogEntryKind::RequestBlocked,
                        Some(request_id),
                        qname,
                    );

                    blocked_domains.push(BlockedDomain {
                        domain_name: qname.clone(),
                        rule: BlockRule::RefuseDnsQuery,
                    })
                }

                Rule::Block(BlockRule::ResolveToStaticIp(ip_addr)) => {
                    self.access_logger.log(
                        client_address,
                        LogEntryKind::RequestBlocked,
                        Some(request_id),
                        format!("{qname} = {ip_addr}"),
                    );

                    blocked_domains.push(BlockedDomain {
                        domain_name: qname.clone(),
                        rule: BlockRule::ResolveToStaticIp(ip_addr),
                    })
                }

                Rule::Allow(AllowRule {
                    allow_all_dns_questions,
                    allowed_destination_sockets,
                }) => {
                    if question.query_class() != DNSClass::IN {
                        if allow_all_dns_questions {
                            continue;
                        } else {
                            self.access_logger.log(
                                client_address,
                                LogEntryKind::RequestWarning,
                                Some(request_id),
                                format!(
                                    "{}: Unexpected QCLASS {} (expected IN)",
                                    qname,
                                    question.query_class(),
                                ),
                            );
                            Self::build_response(&request, ResponseCode::Refused, buffer);
                            return RequestReaction::RespondToClient;
                        }
                    }

                    if question.query_type() != RecordType::A
                        && question.query_type() != RecordType::AAAA
                    {
                        if allow_all_dns_questions {
                            continue;
                        } else {
                            self.access_logger.log(
                                client_address,
                                LogEntryKind::RequestWarning,
                                Some(request_id),
                                format!(
                                    "{}: Unexpected QTYPE {} (expected A or AAAA)",
                                    qname,
                                    question.query_type(),
                                ),
                            );
                            Self::build_response(&request, ResponseCode::Refused, buffer);
                            return RequestReaction::RespondToClient;
                        }
                    }

                    allowed_domains.push(AllowedDomain {
                        domain_name: qname.clone(),
                        socket_addrs: allowed_destination_sockets,
                    });
                }
            }
        }

        if !blocked_domains.is_empty() {
            let mut resolve_to_static_ips = blocked_domains
                .into_iter()
                .filter_map(|entry| match entry.rule {
                    BlockRule::RefuseDnsQuery => None,
                    BlockRule::ResolveToStaticIp(ip_addr) => Some((entry.domain_name, ip_addr)),
                })
                .peekable();

            // If there is at least one entry which demands returning a static IP, we return those.
            // Otherwise, we refuse the request.
            if resolve_to_static_ips.peek().is_some() {
                self.build_response_with_static_ip(
                    client_address,
                    request,
                    resolve_to_static_ips,
                    buffer,
                );
            } else {
                Self::build_response(&request, ResponseCode::Refused, buffer);
            }

            return RequestReaction::RespondToClient;
        }

        if allowed_domains.is_empty() {
            // No destination sockets will be allowed in the firewall, but the DNS request itself will be allowed
            self.access_logger.log(
                client_address,
                LogEntryKind::RequestOnlyAllowed,
                Some(request_id),
                "",
            );
        } else {
            for allowed_domain in &allowed_domains {
                if allowed_domain.socket_addrs.is_empty() {
                    // Access to the domain's IP addresses will remain blocked in the firewall
                    self.access_logger.log(
                        client_address,
                        LogEntryKind::RequestOnlyAllowed,
                        Some(request_id),
                        &allowed_domain.domain_name,
                    );
                } else {
                    self.access_logger.log(
                        client_address,
                        LogEntryKind::RequestAndNetworkAllowed,
                        Some(request_id),
                        &allowed_domain.domain_name,
                    );
                }
            }
        }

        // Replace request ID by a randomly generated one (to prevent potential ID clashes on malicious client input)
        let forwarded_request_id: u16 = rand::thread_rng().gen();

        let request_header = *request.header();

        // The DNS library may not support some parts of the request (and could omit them when re-encoding).
        // Therefore, we replace the ID of the request directly in the buffer.
        // This ensures that the whole request is being forwarded.
        buffer[..2].copy_from_slice(&forwarded_request_id.to_be_bytes());

        RequestReaction::ForwardToUpstream {
            forwarded_request: ForwardedRequest {
                original_request_header: request_header,
                request_id: forwarded_request_id,
                allowed_domains,
            },
        }
    }

    pub async fn process_upstream_response(
        &self,
        client_address: IpAddr,
        buffer: &mut Vec<u8>,
        forwarded_request: &ForwardedRequest,
    ) -> ResponseReaction {
        // Parse response
        let response = match hickory_proto::op::Message::from_vec(buffer) {
            Ok(response) => response,
            Err(e) => {
                self.access_logger.log(
                    client_address,
                    LogEntryKind::ResponseError,
                    Some(forwarded_request.request_id),
                    format!("Response decoding failed: {e:#}"),
                );
                return ResponseReaction::Discard;
            }
        };

        // Process response
        if response.id() != forwarded_request.request_id {
            // Unrelated response, ignore
            self.access_logger.log(
                client_address,
                LogEntryKind::ResponseError,
                Some(forwarded_request.request_id),
                format!(
                    "Received unrelated request ID (expected {}, got {})",
                    forwarded_request.request_id,
                    response.id()
                ),
            );
            return ResponseReaction::Discard;
        }

        if response.op_code() != OpCode::Query || response.response_code() != ResponseCode::NoError
        {
            self.access_logger.log(
                client_address,
                LogEntryKind::ResponseError,
                Some(forwarded_request.original_request_header.id()),
                format!(
                    "Upstream returned error (OPCODE {:?}, RCODE {})",
                    response.op_code(),
                    response.response_code()
                ),
            );
            // Response does not contain expected answer, we don't further parse it, but forward it
            // to the client
            return forward(buffer, forwarded_request);
        }

        // We assume the upstream DNS server is trustworthy and do not cross-check the questions
        // section against the original request.

        let mut firewall_reconfigured = false;

        for answer in response.answers() {
            if answer.dns_class() != DNSClass::IN {
                continue;
            }

            let ip_address = match answer.data() {
                Some(RData::A(record)) => {
                    if !client_address.is_loopback() && !client_address.is_ipv4() {
                        // Ignore resolved address when client is not localhost and uses other IP family.
                        // Both client and destination must use the same IP family in order to insert firewall rules,
                        // unless client == localhost, in which case IP-family independent rules can be added.
                        continue;
                    }
                    IpAddr::V4(**record)
                }
                Some(RData::AAAA(record)) => {
                    if !client_address.is_loopback() && !client_address.is_ipv6() {
                        // See RData::A above
                        continue;
                    }
                    IpAddr::V6(**record)
                }
                _ => continue,
            };

            for allowed_domain in
                forwarded_request.find_allowed_domains_with_cnames(&response, answer.name().clone())
            {
                let ttl = chrono::Duration::seconds(answer.ttl() as i64);
                let ttl = ttl.clamp(self.min_ttl, self.max_ttl);

                for socket_addr in allowed_domain.socket_addrs {
                    let firewall_result = self
                        .firewall_backend
                        .add_temporary_allow_rule(
                            client_address,
                            ip_address,
                            socket_addr,
                            ttl,
                            &allowed_domain.domain_name.to_string(),
                        )
                        .await;

                    match firewall_result {
                        Ok(()) => {
                            self.access_logger.log(
                                client_address,
                                LogEntryKind::ResponseForwardedAndFirewallRuleAdded,
                                Some(forwarded_request.original_request_header.id()),
                                format!(
                                    "{} [{}]:{}:{} TTL:{}",
                                    allowed_domain.domain_name,
                                    ip_address,
                                    socket_addr.protocol,
                                    socket_addr.port,
                                    ttl.num_seconds()
                                ),
                            );

                            firewall_reconfigured = true
                        }

                        Err(()) => {
                            self.access_logger.log(
                                client_address,
                                LogEntryKind::ResponseError,
                                Some(forwarded_request.original_request_header.id()),
                                format!(
                                    "{} [{}]:{}:{} TTL:{} Firewall configuration failed",
                                    allowed_domain.domain_name,
                                    ip_address,
                                    socket_addr.protocol,
                                    socket_addr.port,
                                    ttl.num_seconds()
                                ),
                            );

                            Self::build_response(
                                &forwarded_request.original_request_header,
                                ResponseCode::ServFail,
                                buffer,
                            );

                            return ResponseReaction::ForwardToClient;
                        }
                    }
                }
            }
        }

        if !firewall_reconfigured {
            // Make sure to log at least something, to indicate that the response went through
            self.access_logger.log(
                client_address,
                LogEntryKind::ResponseOnlyForwarded,
                Some(forwarded_request.original_request_header.id()),
                "",
            );
        }

        forward(buffer, forwarded_request)
    }

    pub fn build_response(
        request: &hickory_proto::op::Header,
        rcode: hickory_proto::op::ResponseCode,
        into_buffer: &mut Vec<u8>,
    ) {
        let mut response = hickory_proto::op::Message::new();

        response
            .set_id(request.id())
            .set_op_code(request.op_code())
            .set_recursion_desired(request.recursion_desired())
            .set_recursion_available(true)
            .set_response_code(rcode);

        into_buffer.clear(); // hickory_proto's encoder assumes the buffer to be empty, otherwise, internal assertions will fail!
        let mut encoder = hickory_proto::serialize::binary::BinEncoder::new(into_buffer);

        response
            .emit(&mut encoder)
            .expect("Failed to encode simple response")
    }

    fn build_response_with_static_ip(
        &self,
        client_address: IpAddr,
        mut request: hickory_proto::op::Message,
        answers: impl Iterator<Item = (hickory_proto::rr::Name, IpAddr)>,
        into_buffer: &mut Vec<u8>,
    ) {
        let mut response = hickory_proto::op::Message::new();

        response
            .set_id(request.id())
            .set_op_code(request.op_code())
            .set_recursion_desired(request.recursion_desired())
            .set_recursion_available(true)
            .set_response_code(hickory_proto::op::ResponseCode::NoError)
            .add_queries(request.take_queries());

        for (name, ip_addr) in answers {
            let mut record = hickory_proto::rr::Record::new();

            record
                .set_name(name)
                .set_dns_class(hickory_proto::rr::DNSClass::IN)
                .set_ttl(60);

            match ip_addr {
                IpAddr::V4(ip_addr) => {
                    record
                        .set_record_type(hickory_proto::rr::RecordType::A)
                        .set_data(Some(hickory_proto::rr::RData::A(ip_addr.into())));
                }
                IpAddr::V6(ip_addr) => {
                    record
                        .set_record_type(hickory_proto::rr::RecordType::AAAA)
                        .set_data(Some(hickory_proto::rr::RData::AAAA(ip_addr.into())));
                }
            }

            response.add_answer(record);
        }

        into_buffer.clear(); // hickory_proto's encoder assumes the buffer to be empty, otherwise, internal assertions will fail!
        let mut encoder = hickory_proto::serialize::binary::BinEncoder::new(into_buffer);

        if let Err(e) = response
            .emit(&mut encoder)
            .context("Failed to encode response with static IPs")
        {
            self.access_logger.log(
                client_address,
                LogEntryKind::ResponseError,
                Some(request.id()),
                format!("Failed to encode response with static IPs: {e:#}"),
            );
            Self::build_response(request.header(), ResponseCode::ServFail, into_buffer);
        }
    }
}

fn forward(buffer: &mut [u8], forwarded_request: &ForwardedRequest) -> ResponseReaction {
    // Replace generated ID with original ID
    buffer[..2].copy_from_slice(&forwarded_request.original_request_header.id().to_be_bytes());
    ResponseReaction::ForwardToClient
}

impl ForwardedRequest {
    /// Find all mappings of the form [allowed domain name] -> [list of socket addr]
    /// for the given `domain_name`. This considers CNAME indirections in the given `response` too.
    fn find_allowed_domains_with_cnames(
        &self,
        response: &hickory_proto::op::Message,
        domain_name: hickory_proto::rr::Name,
    ) -> Vec<AllowedDomain> {
        let mut result = Vec::new();

        // We iterate over the list of names while appending resolved CNAMEs at the same time.
        // CNAMEs will only be added if they were not already traversed before, preventing any loops.
        let mut name_list = vec![domain_name];

        let mut i = 0;
        while i < name_list.len() {
            let name = name_list[i].clone();

            // Try to find domain name directly
            result.extend(
                self.allowed_domains
                    .iter()
                    .filter(|v| v.domain_name == name)
                    .cloned(),
            );

            // Try to find CNAMEs pointing to it
            for answer in response.answers() {
                if answer.dns_class() == DNSClass::IN {
                    if let Some(RData::CNAME(cname)) = answer.data() {
                        if **cname == name {
                            let cname_source_domain_name = answer.name();
                            // Only consider this CNAME's source domain if we didn't process it
                            // previously
                            if !name_list.contains(cname_source_domain_name) {
                                name_list.push(cname_source_domain_name.clone());
                            }
                        }
                    }
                }
            }

            i += 1;
        }

        result
    }
}
